name: Publish to ADO Artifacts

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      specific_version:
        description: 'Specific version to upload (leave empty for latest)'
        required: false
        type: string
      upload_to_ado:
        description: 'Allow upload to ADO for manual version run'
        required: false
        type: boolean
        default: true

jobs:
  publish:
    runs-on: ubuntu-latest
    environment:
      name: PUBLISH_TO_ADO
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get release info
        id: release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Function to get release info
          get_release_info() {
            local release="$1"
            local assets=$(echo "$release" | jq -r '.assets[] | .name')
            local release_id=$(echo "$release" | jq -r '.id')
            local tag_name=$(echo "$release" | jq -r '.tag_name')
            
            echo "ASSETS<<EOF" >> $GITHUB_OUTPUT
            echo "$assets" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "RELEASE_ID=$release_id" >> $GITHUB_OUTPUT
            echo "RELEASE_TAG=$tag_name" >> $GITHUB_OUTPUT
          }

          if [ -n "${{ github.event.inputs.specific_version }}" ]; then
            echo "Using manually specified version"
            VERSION="${{ github.event.inputs.specific_version }}"
            [[ $VERSION != v* ]] && VERSION="v$VERSION"
            
            RELEASE=$(curl -sH "Authorization: token $GITHUB_TOKEN" \
                     "https://api.github.com/repos/${{ github.repository }}/releases/tags/$VERSION")
            get_release_info "$RELEASE"

          elif [ "${{ github.event_name }}" = "release" ]; then
            echo "Using triggered release version"
            RELEASE=$(curl -sH "Authorization: token $GITHUB_TOKEN" \
                     "https://api.github.com/repos/${{ github.repository }}/releases/${{ github.event.release.id }}")
            get_release_info "$RELEASE"

          else
            echo "Fetching latest release"
            RELEASE=$(curl -sH "Authorization: token $GITHUB_TOKEN" \
                     "https://api.github.com/repos/${{ github.repository }}/releases/latest")
            get_release_info "$RELEASE"
          fi

      - name: Download release assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_TAG: ${{ steps.release.outputs.RELEASE_TAG }}
        run: |
          mkdir -p downloads
          cd downloads
          echo "Downloading assets for release $RELEASE_TAG"
          gh release download $RELEASE_TAG -p 'failsafe*.*' -D .
          echo "Downloaded assets:"
          ls -la

      - name: Parse asset versions
        id: parse_versions
        run: |
          # Function to extract version from asset name
            parse_asset_version() {
            local asset_name="$1"
            local base_name=""
            local version=""
            local is_latest="false"
            
            # Remove .jar extension if present
            asset_name=${asset_name%.jar}
            
            # Debug output
            echo "Processing asset: $asset_name"
            
            if [[ $asset_name == *"-latest"* ]]; then
                is_latest="true"
                base_name=$(echo "$asset_name" | sed -E 's/-latest$//')
                # Get version from the actual versioned file if available
                for file in downloads/*; do
                if [[ $file =~ ${base_name}-([0-9]+\.[0-9]+\.[0-9]+) ]]; then
                    version="${BASH_REMATCH[1]}"
                    break
                fi
                done
            # Match pattern like name-name-1.0.30
            elif [[ $asset_name =~ ^(failsafe-[^-]+)-([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
                base_name="${BASH_REMATCH[1]}"
                version="${BASH_REMATCH[2]}"
                echo "Matched standard version pattern - Base: $base_name, Version: $version"
            # Version pattern with 'v' prefix
            elif [[ $asset_name =~ ^(.*)-v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
                base_name="${BASH_REMATCH[1]}"
                version="${BASH_REMATCH[2]}"
                echo "Matched v-prefix pattern - Base: $base_name, Version: $version"
            else
                echo "WARNING: Could not parse version from $asset_name"
                return 1
            fi
            
            echo "Final parsing - Base: $base_name, Version: $version, Is Latest: $is_latest"
            echo "$base_name|$version|$is_latest"
            }
            
            # Process each asset and create a mapping file
            echo "ASSET_MAPPING<<EOF" >> $GITHUB_OUTPUT
            for asset in downloads/*; do
            filename=$(basename "$asset")
            echo "Processing file: $filename"
            if parsed=$(parse_asset_version "$filename"); then
                echo "$filename|$parsed" >> $GITHUB_OUTPUT
                echo "Successfully parsed: $filename|$parsed"
            else
                echo "Failed to parse: $filename"
            fi
            done
            echo "EOF" >> $GITHUB_OUTPUT
    
    ## TO DO when service prinicpal or other than PAT token needs to be used 
    # - name: Authenticate to Azure via OIDC  
    #   uses: azure/login@v2  
    #   with:  
    #     client-id: ${{ secrets.ADO_FEED_PAT }}  
    #     allow-no-subscriptions: true

      - name: Install and configure Azure CLI
        run: |
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
          az extension add --name azure-devops
          az extension update --name azure-devops
          az devops configure --defaults organization="${{ vars.ADO_ORG }}" project="${{ vars.ADO_PROJECT }}"

      - name: Publish to ADO
        if: github.event.inputs.upload_to_ado != 'false'
        env:
          ASSET_MAPPING: ${{ steps.parse_versions.outputs.ASSET_MAPPING }}
          ADO_TOKEN: ${{ secrets.ADO_FEED_PAT }}
        run: |
          export AZURE_DEVOPS_PAT=$ADO_TOKEN
          az devops login

          echo "$ASSET_MAPPING" | while IFS='|' read -r filename base_name version is_latest; do
            if [ -n "$base_name" ] && [ -n "$version" ]; then
              echo "Publishing $filename (Name: $base_name, Version: $version)"
              
              # Upload the artifact
              az artifacts universal publish \
                --organization "${{ vars.ADO_ORG }}" \
                --project "${{ vars.ADO_PROJECT }}" \
                --scope project \
                --feed "${{ vars.ADO_FEED }}" \
                --name "$base_name" \
                --version "$version" \
                --path "downloads/$filename" \
                --description "Published from GitHub Release $base_name"
              
              # Update latest tag always as fix forward
              echo "Updategin latest alias for $base_name"
              az artifacts universal update \  
                --organization "${{ vars.ADO_ORG }}" \ 
                --project "${{ vars.ADO_PROJECT }}" \  
                --feed "${{ vars.ADO_FEED }}" \  
                --name "$base_name" \  
                --version "$version" \  
                --set-alias latest  \
                --path "downloads/$filename" \
                --desciption "Latest version from GitHub Release $base_name"
            fi
          done
          az devops logout

#           WARNING: Failed to store PAT using keyring; falling back to file storage.
# WARNING: You can clear the stored credential by running az devops logout.
# WARNING: Refer https://aka.ms/azure-devops-cli-auth to know more on sign in with PAT.
# Publishing failsafe-IDCTPaymentsEngine (Name: 1.0.30, Version: false)
# ERROR: Failed to update Universal Packages tooling.
#  TF400813: The user 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa' is not authorized to access this resource.
# Error: Process completed with exit code 1.
