name: Monitor Azure DevOps Pipeline Details

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  trigger-ado-pipeline:
    runs-on: ubuntu-latest
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      - name: Install Azure DevOps CLI extension
        run: az extension add --name azure-devops
          
      - name: Set Azure DevOps organization and project
        run: |
          az devops configure --defaults organization=https://dev.azure.com/{organization} project={project}
          
      - name: Trigger Pipeline
        id: trigger
        run: |
          RUN_DETAILS=$(az pipelines run --id {pipelineId} --branch main -o json)
          RUN_ID=$(echo $RUN_DETAILS | jq -r '.id')
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "Pipeline triggered: Build $RUN_ID"

      - name: Monitor Pipeline Progress
        run: |
          RUN_ID=${{ steps.trigger.outputs.run_id }}
          TIMEOUT_MINUTES=30
          POLL_INTERVAL_SECONDS=30
          MAX_POLLS=$((TIMEOUT_MINUTES * 60 / POLL_INTERVAL_SECONDS))
          
          monitor_pipeline() {
            local RESULT=$(az pipelines runs show --id $RUN_ID -o json)
            local TIMELINE=$(az pipelines runs show --id $RUN_ID --detect false --query-timeline -o json)
            
            # Get overall pipeline status
            local STATUS=$(echo $RESULT | jq -r '.status')
            local RESULT_STRING=$(echo $RESULT | jq -r '.result // "null"')
            
            echo "Pipeline Status: $STATUS ($RESULT_STRING)"
            
            # Process each stage
            echo "$TIMELINE" | jq -c '.records[] | select(.type == "Stage")' | while read -r stage; do
              local STAGE_NAME=$(echo $stage | jq -r '.name')
              local STAGE_STATE=$(echo $stage | jq -r '.state')
              local STAGE_RESULT=$(echo $stage | jq -r '.result // "pending"')
              
              echo "Stage: $STAGE_NAME - State: $STAGE_STATE ($STAGE_RESULT)"
              
              # Process jobs within this stage
              echo "$TIMELINE" | jq -c --arg stageName "$STAGE_NAME" \
                '.records[] | select(.type == "Job" and .parentId == ($stageName))' | while read -r job; do
                local JOB_NAME=$(echo $job | jq -r '.name')
                local JOB_STATE=$(echo $job | jq -r '.state')
                local JOB_RESULT=$(echo $job | jq -r '.result // "pending"')
                
                echo "  Job: $JOB_NAME - State: $JOB_STATE ($JOB_RESULT)"
                
                # Check for approval wait
                if [[ "$JOB_STATE" == "pending" ]]; then
                  local APPROVAL_CHECK=$(az pipelines runs show --id $RUN_ID --detect false -o json | \
                    jq -r '.approvals[] | select(.status == "pending") | .instructions // empty')
                  
                  if [[ ! -z "$APPROVAL_CHECK" ]]; then
                    echo "⚠️ WARNING: Pipeline is waiting for approval:"
                    echo "$APPROVAL_CHECK"
                    echo "Pipeline monitoring stopped - manual intervention required"
                    echo "Visit: https://dev.azure.com/{organization}/{project}/_build/results?buildId=$RUN_ID"
                    exit 0
                  fi
                fi
                
                # Get task details for failed jobs
                if [[ "$JOB_RESULT" == "failed" ]]; then
                  echo "    Failed Tasks:"
                  echo "$TIMELINE" | jq -c --arg jobId "$(echo $job | jq -r '.id')" \
                    '.records[] | select(.type == "Task" and .parentId == ($jobId) and .result == "failed")' | \
                    while read -r task; do
                    local TASK_NAME=$(echo $task | jq -r '.name')
                    local TASK_ERROR=$(echo $task | jq -r '.issues[].message // "No error message available"')
                    echo "      - $TASK_NAME: $TASK_ERROR"
                  done
                fi
              done
            done
            
            # Return pipeline status for main loop control
            echo $STATUS
          }
          
          for ((i=1; i<=MAX_POLLS; i++)); do
            echo "Check $i/$MAX_POLLS"
            
            STATUS=$(monitor_pipeline)
            
            if [[ "$STATUS" == "completed" ]]; then
              echo "Pipeline execution finished"
              
              # Get final result
              FINAL_RESULT=$(az pipelines runs show --id $RUN_ID -o json | jq -r '.result')
              if [[ "$FINAL_RESULT" == "succeeded" ]]; then
                echo "✅ Pipeline completed successfully"
                exit 0
              else
                echo "❌ Pipeline failed"
                exit 1
              fi
            fi
            
            echo "Waiting $POLL_INTERVAL_SECONDS seconds before next check..."
            sleep $POLL_INTERVAL_SECONDS
          done
          
          echo "⚠️ Timeout reached. Pipeline is still running."
          exit 1